<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Algoogle]]></title>
  <link href="http://algoogle.hadrori.jp/atom.xml" rel="self"/>
  <link href="http://algoogle.hadrori.jp/"/>
  <updated>2014-04-29T16:39:07+09:00</updated>
  <id>http://algoogle.hadrori.jp/</id>
  <author>
    <name><![CDATA[hadrori]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Union Find Tree]]></title>
    <link href="http://algoogle.hadrori.jp/union-find/"/>
    <updated>2014-04-29T00:00:00+09:00</updated>
    <id>http://algoogle.hadrori.jp/union-find</id>
    <content type="html"><![CDATA[<h4 id="section">基本情報</h4>

<hr />

<table>
  <tbody>
    <tr>
      <td>計算量</td>
      <td>O(a(N))</td>
    </tr>
    <tr>
      <td>用途</td>
      <td>データの集合の併合と同じ集合に属しているかの判定</td>
    </tr>
  </tbody>
</table>

<p>N := 頂点数<br />
a := アッカーマン関数の逆関数</p>

<h4 id="section-1">問題</h4>

<hr />

<ul>
  <li><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1127">AOJ 1127 “Building a Space Station”</a>  </li>
  <li><a href="http://poj.org/problem?id=1258">POJ 1258 “Agri-Net”</a>  </li>
  <li><a href="http://poj.org/problem?id=1984">POJ 1984 “Navigation-Nightmare”</a>  </li>
  <li><a href="http://poj.org/problem?id=2377">POJ 2377 “Bad Cowtractors”</a>  </li>
  <li><a href="http://poj.org/problem?id=3625">POJ 3625 “Building Roads”</a>  </li>
</ul>

<h4 id="section-2">解説</h4>

<hr />

<p>Union Find木では共通の親を持つかどうかで同じ木に属しているか判定する.<br />
また, 2つの要素を併合する場合は片方の親の子にもう片方の木を入れる.<br />
偏りをなくすために木のランクを保存しておいてランクの高い方に小さい方を併合するようにする.<br />
親を見つけるときにその途中結果をメモする(親に直接つなぐ).</p>

<h4 id="section-3">コード</h4>

<hr />

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span> (union_find.cpp)</span> <a href="http://algoogle.hadrori.jp/downloads/code/union_find.cpp">download</a></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
</pre></td><td class="code"><pre><code class="cpp"><span class="line"><span class="k">struct</span> <span class="n">union_find</span><span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">rnk</span><span class="p">[</span><span class="n">MAX</span><span class="p">],</span> <span class="n">par</span><span class="p">[</span><span class="n">MAX</span><span class="p">];</span>
</span><span class="line">
</span><span class="line">    <span class="n">union_find</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span> <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">rnk</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">par</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;}</span>
</span><span class="line">
</span><span class="line">    <span class="kt">int</span> <span class="n">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
</span><span class="line">        <span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">par</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
</span><span class="line">        <span class="k">else</span> <span class="k">return</span> <span class="n">par</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">par</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="kt">void</span> <span class="n">unite</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">){</span>
</span><span class="line">        <span class="n">x</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="n">y</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
</span><span class="line">        <span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span><span class="line">        <span class="k">if</span><span class="p">(</span><span class="n">rnk</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">rnk</span><span class="p">[</span><span class="n">y</span><span class="p">])</span> <span class="n">par</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span><span class="line">        <span class="k">else</span><span class="p">{</span>
</span><span class="line">            <span class="n">par</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
</span><span class="line">            <span class="k">if</span><span class="p">(</span><span class="n">rnk</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="n">rnk</span><span class="p">[</span><span class="n">y</span><span class="p">])</span> <span class="n">rnk</span><span class="p">[</span><span class="n">y</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="kt">bool</span> <span class="n">same</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">){</span>
</span><span class="line">        <span class="n">x</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="n">y</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
</span><span class="line">        <span class="k">return</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Segment Tree]]></title>
    <link href="http://algoogle.hadrori.jp/segment-tree/"/>
    <updated>2014-04-29T00:00:00+09:00</updated>
    <id>http://algoogle.hadrori.jp/segment-tree</id>
    <content type="html"><![CDATA[<h4 id="section">基本情報</h4>

<hr />

<table>
  <tbody>
    <tr>
      <td>計算量</td>
      <td>O(log N)</td>
    </tr>
    <tr>
      <td>用途</td>
      <td>区間に対するクエリの処理</td>
    </tr>
  </tbody>
</table>

<p>N := 区間の幅  </p>

<h4 id="section-1">問題</h4>

<hr />

<h4 id="section-2">解説</h4>

<hr />

<p>Segment Treeは主に区間に対するクエリを処理するために使われる.<br />
完全二分木で実装されるので各クエリの計算量はO(log N)になる.<br />
自由度が高く, 区間を扱う様々なものに利用される.<br />
コードではRMQの実装.  </p>

<h4 id="section-3">コード</h4>

<hr />

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span> (segtree.cpp)</span> <a href="http://algoogle.hadrori.jp/downloads/code/segtree.cpp">download</a></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
</pre></td><td class="code"><pre><code class="cpp"><span class="line"><span class="k">struct</span> <span class="n">segment_tree</span><span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">N</span><span class="p">,</span> <span class="n">dat</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">MAX</span><span class="p">];</span>
</span><span class="line">    <span class="n">segment_tree</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
</span><span class="line">        <span class="n">N</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">        <span class="k">while</span><span class="p">(</span><span class="n">N</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="n">N</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
</span><span class="line">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">            <span class="n">dat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">inf</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="c1">// update k th element</span>
</span><span class="line">    <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">a</span><span class="p">){</span>
</span><span class="line">        <span class="n">k</span> <span class="o">+=</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// leaf</span>
</span><span class="line">        <span class="n">dat</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
</span><span class="line">        <span class="k">while</span><span class="p">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class="line">            <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span><span class="line">            <span class="n">dat</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">dat</span><span class="p">[</span><span class="n">k</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">dat</span><span class="p">[</span><span class="n">k</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span><span class="p">]);</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="c1">// min [a, b)</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">query</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span> <span class="k">return</span> <span class="n">query</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">);}</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">query</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">){</span>
</span><span class="line">        <span class="k">if</span><span class="p">(</span><span class="n">r</span> <span class="o">&lt;=</span> <span class="n">a</span> <span class="n">or</span> <span class="n">b</span> <span class="o">&lt;=</span> <span class="n">l</span><span class="p">)</span> <span class="k">return</span> <span class="n">inf</span><span class="p">;</span>
</span><span class="line">        <span class="k">if</span><span class="p">(</span><span class="n">a</span> <span class="o">&lt;=</span> <span class="n">l</span> <span class="n">and</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">)</span> <span class="k">return</span> <span class="n">dat</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
</span><span class="line">        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span><span class="line">        <span class="k">return</span> <span class="n">min</span><span class="p">(</span><span class="n">query</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">k</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span> <span class="n">query</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">k</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">r</span><span class="p">));</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Prim法]]></title>
    <link href="http://algoogle.hadrori.jp/prim/"/>
    <updated>2014-04-29T00:00:00+09:00</updated>
    <id>http://algoogle.hadrori.jp/prim</id>
    <content type="html"><![CDATA[<h4 id="section">基本情報</h4>

<hr />

<table>
  <tbody>
    <tr>
      <td>計算量</td>
      <td>O(E log V)</td>
    </tr>
    <tr>
      <td>用途</td>
      <td>最小全域木を求める</td>
    </tr>
  </tbody>
</table>

<p>E := 辺の数<br />
V := 頂点数  </p>

<h4 id="section-1">問題</h4>

<hr />

<ul>
  <li><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1127">AOJ 1127 “Building a Space Station”</a>  </li>
  <li><a href="http://poj.org/problem?id=1258">POJ 1258 “Agri-Net”</a>  </li>
  <li><a href="http://poj.org/problem?id=2377">POJ 2377 “Bad Cowtractors”</a>  </li>
  <li><a href="http://poj.org/problem?id=3625">POJ 3625 “Building Roads”</a>  </li>
</ul>

<h4 id="section-2">解説</h4>

<hr />

<p>すでに到達した頂点の集合からまだ到達していない頂点の集合への辺のうち, コストが最小のものを選んでいくことで最小全域木を構成する.<br />
Dijkstra法と似ている.  </p>

<h4 id="section-3">コード</h4>

<hr />

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span> (prim.cpp)</span> <a href="http://algoogle.hadrori.jp/downloads/code/prim.cpp">download</a></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
</pre></td><td class="code"><pre><code class="cpp"><span class="line"><span class="k">typedef</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pii</span><span class="p">;</span> <span class="c1">// (cst, to)</span>
</span><span class="line"><span class="n">vector</span><span class="o">&lt;</span><span class="n">pii</span><span class="o">&gt;</span> <span class="n">G</span><span class="p">[</span><span class="n">MAX</span><span class="p">];</span>
</span><span class="line"><span class="kt">bool</span> <span class="n">used</span><span class="p">[</span><span class="n">MAX</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="n">prim</span><span class="p">(){</span>
</span><span class="line">    <span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">pii</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">pii</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">greater</span><span class="o">&lt;</span><span class="n">pii</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">que</span><span class="p">;</span>
</span><span class="line">    <span class="n">memset</span><span class="p">(</span><span class="n">used</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">used</span><span class="p">));</span>
</span><span class="line">    <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">pii</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">que</span><span class="p">.</span><span class="n">empty</span><span class="p">()){</span>
</span><span class="line">        <span class="kt">int</span> <span class="n">cst</span> <span class="o">=</span> <span class="n">que</span><span class="p">.</span><span class="n">top</span><span class="p">().</span><span class="n">first</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">que</span><span class="p">.</span><span class="n">top</span><span class="p">().</span><span class="n">second</span><span class="p">;</span>
</span><span class="line">        <span class="n">que</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span><span class="line">        <span class="k">if</span><span class="p">(</span><span class="n">used</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span>
</span><span class="line">        <span class="n">used</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">        <span class="n">ret</span> <span class="o">+=</span> <span class="n">cst</span><span class="p">;</span>
</span><span class="line">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">G</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">            <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">i</span><span class="p">]);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kruskal法]]></title>
    <link href="http://algoogle.hadrori.jp/kruskal/"/>
    <updated>2014-04-29T00:00:00+09:00</updated>
    <id>http://algoogle.hadrori.jp/kruskal</id>
    <content type="html"><![CDATA[<h4 id="section">基本情報</h4>

<hr />

<table>
  <tbody>
    <tr>
      <td>計算量</td>
      <td>O(E log V)</td>
    </tr>
    <tr>
      <td>用途</td>
      <td>最小全域木(森)を求める</td>
    </tr>
  </tbody>
</table>

<p>E := 辺の数<br />
V := 頂点数  </p>

<h4 id="section-1">問題</h4>

<hr />

<ul>
  <li><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1127">AOJ 1127 “Building a Space Station”</a>  </li>
  <li><a href="http://poj.org/problem?id=1258">POJ 1258 “Agri-Net”</a>  </li>
  <li><a href="http://poj.org/problem?id=2377">POJ 2377 “Bad Cowtractors”</a>  </li>
  <li><a href="http://poj.org/problem?id=3625">POJ 3625 “Building Roads”</a>  </li>
</ul>

<h4 id="section-2">解説</h4>

<hr />

<p>グラフの辺のリストをコストの小さい方から処理していき, 辺の両端の頂点が同じ木に属していなければその辺を使う.<br />
同じ木に属しているかどうかの判定には<a href="http://algoogle.hadrori.jp/union-find/">Union-Find</a>を利用する.  </p>

<h4 id="section-3">コード</h4>

<hr />

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span> (kruskal.cpp)</span> <a href="http://algoogle.hadrori.jp/downloads/code/kruskal.cpp">download</a></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
</pre></td><td class="code"><pre><code class="cpp"><span class="line"><span class="k">struct</span> <span class="n">edge</span><span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">cst</span><span class="p">;</span>
</span><span class="line">    <span class="n">edge</span><span class="p">(){}</span>
</span><span class="line">    <span class="n">edge</span><span class="p">(</span><span class="kt">int</span> <span class="n">from</span><span class="p">,</span> <span class="kt">int</span> <span class="n">to</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cst</span><span class="p">)</span><span class="o">:</span><span class="n">from</span><span class="p">(</span><span class="n">from</span><span class="p">),</span><span class="n">to</span><span class="p">(</span><span class="n">to</span><span class="p">),</span><span class="n">cst</span><span class="p">(</span><span class="n">cst</span><span class="p">){}</span>
</span><span class="line">    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">edge</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">)</span><span class="k">const</span><span class="p">{</span><span class="k">return</span> <span class="n">cst</span> <span class="o">&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">cst</span><span class="p">;}</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="c1">// Eが連結ならTに最小全域木が入る</span>
</span><span class="line"><span class="kt">int</span> <span class="n">kruskal</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">edge</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">E</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">edge</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">){</span>
</span><span class="line">    <span class="n">sort</span><span class="p">(</span><span class="n">E</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">E</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span><span class="line">    <span class="n">T</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span><span class="line">    <span class="n">union_find</span> <span class="n">uf</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">E</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span><span class="line">        <span class="n">edge</span> <span class="o">&amp;</span><span class="n">e</span> <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class="line">        <span class="k">if</span><span class="p">(</span><span class="n">uf</span><span class="p">.</span><span class="n">same</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">from</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">to</span><span class="p">))</span> <span class="k">continue</span><span class="p">;</span>
</span><span class="line">        <span class="n">uf</span><span class="p">.</span><span class="n">unite</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">from</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">to</span><span class="p">);</span>
</span><span class="line">        <span class="n">w</span> <span class="o">+=</span> <span class="n">e</span><span class="p">.</span><span class="n">cst</span><span class="p">;</span>
</span><span class="line">        <span class="n">T</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="n">w</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[座標圧縮]]></title>
    <link href="http://algoogle.hadrori.jp/compress/"/>
    <updated>2014-04-29T00:00:00+09:00</updated>
    <id>http://algoogle.hadrori.jp/compress</id>
    <content type="html"><![CDATA[<h4 id="section">基本情報</h4>

<hr />

<table>
  <tbody>
    <tr>
      <td>計算量</td>
      <td>初期化 O(N log N), 圧縮 O(log N), 展開 O(1)</td>
    </tr>
    <tr>
      <td>用途</td>
      <td>座標を圧縮する</td>
    </tr>
  </tbody>
</table>

<p>N := 圧縮する座標の数  </p>

<h4 id="section-1">問題</h4>

<hr />

<ul>
  <li><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1337">AOJ 1337 “Count the Regions”</a>  </li>
  <li><a href="http://poj.org/problem?id=2430">POJ 2430 “Lazy Cow”</a>  </li>
  <li><a href="http://poj.org/problem?id=3666">POJ 3666 “Making the Grade”</a>  </li>
</ul>

<h4 id="section-2">解説</h4>

<hr />

<p>入力の個数に対して考えられる座標の範囲が広い時, 座標の大小関係を維持しつつ値の範囲を狭める.<br />
コードではzipで圧縮後の座標, unzipで圧縮前の座標を受け取る.  </p>

<h4 id="section-3">コード</h4>

<hr />

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span> (compress.cpp)</span> <a href="http://algoogle.hadrori.jp/downloads/code/compress.cpp">download</a></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class="cpp"><span class="line"><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">zip</span><span class="p">;</span>
</span><span class="line"><span class="kt">int</span> <span class="n">unzip</span><span class="p">[</span><span class="n">MAP</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="n">compress</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">){</span>
</span><span class="line">    <span class="n">sort</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">x</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span><span class="line">    <span class="n">x</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">unique</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">x</span><span class="p">.</span><span class="n">end</span><span class="p">()),</span><span class="n">x</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span><span class="line">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span><span class="line">        <span class="n">zip</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span><span class="line">        <span class="n">unzip</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="n">x</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Biniry Indexed Tree]]></title>
    <link href="http://algoogle.hadrori.jp/binary-indexed-tree/"/>
    <updated>2014-04-29T00:00:00+09:00</updated>
    <id>http://algoogle.hadrori.jp/binary-indexed-tree</id>
    <content type="html"><![CDATA[<h4 id="section">基本情報</h4>

<hr />

<table>
  <tbody>
    <tr>
      <td>計算量</td>
      <td>O(log N)</td>
    </tr>
    <tr>
      <td>用途</td>
      <td>区間の和を求める. 値を加える.</td>
    </tr>
  </tbody>
</table>

<p>N := 区間の幅  </p>

<h4 id="section-1">問題</h4>

<hr />

<ul>
  <li><a href="http://poj.org/problem?id=1990">POJ 1990 “Agri-Net”</a>  </li>
</ul>

<h4 id="section-2">解説</h4>

<hr />
<p>BIT(Binary Indexed Tree)は区間の和を求めるのと1つの場所の値に加算するのををO(log N)で行えるデータ構造. 
実現にビットを用いていて実装が非常に楽.<br />
値の加算はi番目の値に加えたい場合は立っているビットの最後のビットを繰り上げていきながらその経路全てを更新する.<br />
和の計算は1からi番目までの値の和の場合, 立っているビットの最後のbitを0にしながらその経路全ての和を返す.  </p>

<p>BITでは1-indexedなので注意する.</p>

<h4 id="section-3">コード</h4>

<hr />

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span> (bit.cpp)</span> <a href="http://algoogle.hadrori.jp/downloads/code/bit.cpp">download</a></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
</pre></td><td class="code"><pre><code class="cpp"><span class="line"><span class="k">struct</span> <span class="n">binary_it</span><span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">bit</span><span class="p">[</span><span class="n">MAX</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">N</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="n">binary_it</span><span class="p">(</span><span class="kt">int</span> <span class="n">N</span><span class="p">)</span><span class="o">:</span><span class="n">N</span><span class="p">(</span><span class="n">N</span><span class="p">){</span>
</span><span class="line">        <span class="n">memset</span><span class="p">(</span><span class="n">bit</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bit</span><span class="p">));</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="kt">int</span> <span class="n">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">){</span> <span class="c1">// sum [1,i]</span>
</span><span class="line">        <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">        <span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="p">){</span>
</span><span class="line">            <span class="n">ret</span> <span class="o">+=</span> <span class="n">bit</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class="line">            <span class="n">i</span> <span class="o">-=</span> <span class="n">i</span><span class="o">&amp;-</span><span class="n">i</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="kt">int</span> <span class="n">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">){</span> <span class="c1">// sum (i,j]</span>
</span><span class="line">        <span class="k">return</span> <span class="n">sum</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">-</span> <span class="n">sum</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="kt">void</span> <span class="n">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
</span><span class="line">        <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">){</span>
</span><span class="line">            <span class="n">bit</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">x</span><span class="p">;</span>
</span><span class="line">            <span class="n">i</span> <span class="o">+=</span> <span class="n">i</span><span class="o">&amp;-</span><span class="n">i</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Warshall-Floyd法]]></title>
    <link href="http://algoogle.hadrori.jp/warshall-floyd/"/>
    <updated>2014-04-28T00:00:00+09:00</updated>
    <id>http://algoogle.hadrori.jp/warshall-floyd</id>
    <content type="html"><![CDATA[<h4 id="section">基本情報</h4>

<hr />

<table>
  <tbody>
    <tr>
      <td>計算量</td>
      <td>O(N^3)</td>
    </tr>
    <tr>
      <td>用途</td>
      <td>全点対最短路を求める</td>
    </tr>
  </tbody>
</table>

<p>N := 頂点数  </p>

<h4 id="section-1">問題</h4>

<hr />

<ul>
  <li><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0189">AOJ 0189 “Convenient Location”</a>  </li>
  <li><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0200">AOJ 0200 “Traveling Alone: One-way Ticket of Youth”</a>  </li>
  <li><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0526">AOJ 0526 “Boat Travel”</a>  </li>
  <li><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2005">AOJ 2005 “Wate Pipe Construction”</a>  </li>
  <li><a href="http://poj.org/problem?id=3615">POJ 3615 “Cow Hurdles”</a>  </li>
</ul>

<h4 id="section-2">解説</h4>

<hr />

<p>Warshall-Floyd法では, グラフ中の任意の2頂点i, j間の最短距離を求める.<br />
あるkに対して同じグラフ中の点0..kまでの中継点を使うとき(必ずしも全てを通るわけではない)の最短路が求まっているとする.<br />
そのとき2頂点i, jとkについてdist[i][k+1]とdist[k+1][j]は共に最短になっている.
よってk+1を経由するかどうかで中継点として頂点0..k+1を使うときのi, j間の最短距離を更新することができる.<br />
dist[i][j] = min(dist[i][j], dist[i][k+1] + dist[k+1][j]);<br />
よってkまでの頂点を中継点を使って最短路が求まっている時, k+1までの頂点を中継点とした最短路も上の更新によって求まる.<br />
当然中継点をひとつも使わない時ははじめから最短になっている.<br />
これらからkについて0からN−ま1で回して, その中で全ての組の最短を更新すれば全ての2点間の最短路が求まることが分かる.  </p>

<p>以上によって全点対最短路がもとまる. またWarshall-Floyd法は3重ループを回すだけで実装できるので制約が許すなら単一始点最短路を求めたいときなどでも使われる(コーディングのスピードを上げるため).</p>

<h4 id="section-3">コード</h4>

<hr />

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span> (warshall_floyd.cpp)</span> <a href="http://algoogle.hadrori.jp/downloads/code/warshall_floyd.cpp">download</a></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="cpp"><span class="line"><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">            <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">+</span><span class="n">dist</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ford-Fulkerson法]]></title>
    <link href="http://algoogle.hadrori.jp/ford-fulkerson/"/>
    <updated>2014-04-28T00:00:00+09:00</updated>
    <id>http://algoogle.hadrori.jp/ford-fulkerson</id>
    <content type="html"><![CDATA[<h4 id="section">基本情報</h4>

<hr />

<table>
  <tbody>
    <tr>
      <td>計算量</td>
      <td>O(FE)</td>
    </tr>
    <tr>
      <td>用途</td>
      <td>最大流を求める</td>
    </tr>
  </tbody>
</table>

<p>F := 最大流の流量
E := 辺の数</p>

<h4 id="section-1">問題</h4>

<hr />

<p><a href="http://algoogle.hadrori.jp/dinic/">Dinic法</a>参照.</p>

<h4 id="section-2">解説</h4>

<hr />

<p>始点から終点までにフローを流せるパスが存在する限りそこに流し続ける.<br />
パスに使った辺の容量は減らし, 逆辺の容量を増やす.<br />
非常に単純.<br />
欠点として容量が無理数である場合, 有限回の操作で終了しないことが知られているが, 競技プログラミングにおいてはそのようなケースは稀.  </p>

<p>また最大流を利用することで, 2部グラフの最大マッチング問題を解くことができる. ソース-&gt;集合A-&gt;集合B-&gt;シンク と容量1の辺を張ることで最大流が最大マッチングに対応する.</p>

<h4 id="section-3">コード</h4>

<hr />

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span> (ford_fulkerson.cpp)</span> <a href="http://algoogle.hadrori.jp/downloads/code/ford_fulkerson.cpp">download</a></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
</pre></td><td class="code"><pre><code class="cpp"><span class="line"><span class="k">struct</span> <span class="n">edge</span><span class="p">{</span><span class="kt">int</span> <span class="n">to</span><span class="p">,</span> <span class="n">cap</span><span class="p">,</span> <span class="n">rev</span><span class="p">;};</span>
</span><span class="line"><span class="n">vector</span><span class="o">&lt;</span><span class="n">edge</span><span class="o">&gt;</span> <span class="n">G</span><span class="p">[</span><span class="n">MAX</span><span class="p">];</span>
</span><span class="line"><span class="kt">bool</span> <span class="n">used</span><span class="p">[</span><span class="n">MAX</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="n">add_edge</span><span class="p">(</span><span class="kt">int</span> <span class="n">from</span><span class="p">,</span> <span class="kt">int</span> <span class="n">to</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cap</span><span class="p">){</span>
</span><span class="line">    <span class="n">G</span><span class="p">[</span><span class="n">from</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">edge</span><span class="p">{</span><span class="n">to</span><span class="p">,</span> <span class="n">cap</span><span class="p">,</span> <span class="kt">int</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">to</span><span class="p">].</span><span class="n">size</span><span class="p">())});</span>
</span><span class="line">    <span class="n">G</span><span class="p">[</span><span class="n">to</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">edge</span><span class="p">{</span><span class="n">from</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">from</span><span class="p">].</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">)});</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="n">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">t</span><span class="p">,</span> <span class="kt">int</span> <span class="n">f</span><span class="p">){</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">t</span><span class="p">)</span> <span class="k">return</span> <span class="n">f</span><span class="p">;</span>
</span><span class="line">    <span class="n">used</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">G</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span><span class="line">        <span class="n">edge</span> <span class="o">&amp;</span><span class="n">e</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
</span><span class="line">        <span class="k">if</span><span class="p">(</span><span class="n">used</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">to</span><span class="p">]</span> <span class="n">or</span> <span class="n">e</span><span class="p">.</span><span class="n">cap</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
</span><span class="line">        <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">to</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">min</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">cap</span><span class="p">));</span>
</span><span class="line">        <span class="k">if</span><span class="p">(</span><span class="n">d</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class="line">            <span class="n">e</span><span class="p">.</span><span class="n">cap</span> <span class="o">-=</span> <span class="n">d</span><span class="p">;</span>
</span><span class="line">            <span class="n">G</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">to</span><span class="p">][</span><span class="n">e</span><span class="p">.</span><span class="n">rev</span><span class="p">].</span><span class="n">cap</span> <span class="o">+=</span> <span class="n">d</span><span class="p">;</span>
</span><span class="line">            <span class="k">return</span> <span class="n">d</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="n">ford_fulkerson</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">t</span><span class="p">){</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">flow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">f</span><span class="p">;</span>
</span><span class="line">    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
</span><span class="line">        <span class="n">memset</span><span class="p">(</span><span class="n">used</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">used</span><span class="p">));</span>
</span><span class="line">        <span class="n">f</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">inf</span><span class="p">);</span>
</span><span class="line">        <span class="k">if</span><span class="p">(</span><span class="n">f</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">flow</span><span class="p">;</span>
</span><span class="line">        <span class="n">flow</span> <span class="o">+=</span> <span class="n">f</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dinic法]]></title>
    <link href="http://algoogle.hadrori.jp/dinic/"/>
    <updated>2014-04-28T00:00:00+09:00</updated>
    <id>http://algoogle.hadrori.jp/dinic</id>
    <content type="html"><![CDATA[<h4 id="section">基本情報</h4>

<hr />

<table>
  <tbody>
    <tr>
      <td>計算量</td>
      <td>O(EV^2)</td>
    </tr>
    <tr>
      <td>用途</td>
      <td>最大流を求める</td>
    </tr>
  </tbody>
</table>

<p>E := 辺の数
V := 頂点数</p>

<h4 id="section-1">問題</h4>

<hr />

<ul>
  <li><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1163">AOJ 1163 “Cards”</a></li>
  <li><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1185">AOJ 1185 “Patisserie ACM”</a></li>
  <li><a href="http://poj.org/problem?id=1274">POJ 1274 “The Perfect Stall”</a></li>
  <li><a href="http://poj.org/problem?id=2112">POJ 2112 “Optimal Milking”</a></li>
  <li><a href="http://poj.org/problem?id=2226">POJ 2226 “Muddy Fields”</a></li>
  <li><a href="http://poj.org/problem?id=2391">POJ 2391 “Ombrophobic Bonvines”</a></li>
  <li><a href="http://poj.org/problem?id=2455">POJ 2455 “Secret Milking Machine”</a></li>
  <li><a href="http://poj.org/problem?id=3041">POJ 3041 “Asteroids”</a></li>
  <li><a href="http://poj.org/problem?id=3281">POJ 3281 “Dining”</a></li>
</ul>

<h4 id="section-2">解説</h4>

<hr />

<p>基本的な部分では<a href="http://algoogle.hadrori.jp/ford-fulkerson/">Ford-Fulkerson</a>と同じ.<br />
levelグラフ(ソースからの最短距離)を構築することで増加パスのうち最短のパスにフローを流す.<br />
そのような経路が存在しなくなったら残余ネットワークでもう一度構築する.<br />
それでも存在しなくなったら終了.  </p>

<h4 id="section-3">コード</h4>

<hr />

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span> (dinic.cpp)</span> <a href="http://algoogle.hadrori.jp/downloads/code/dinic.cpp">download</a></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
</pre></td><td class="code"><pre><code class="cpp"><span class="line"><span class="k">struct</span> <span class="n">edge</span><span class="p">{</span><span class="kt">int</span> <span class="n">to</span><span class="p">,</span> <span class="n">cap</span><span class="p">,</span> <span class="n">rev</span><span class="p">;};</span>
</span><span class="line"><span class="n">vector</span><span class="o">&lt;</span><span class="n">edge</span><span class="o">&gt;</span> <span class="n">G</span><span class="p">[</span><span class="n">MAX</span><span class="p">];</span>
</span><span class="line"><span class="kt">int</span> <span class="n">level</span><span class="p">[</span><span class="n">MAX</span><span class="p">],</span> <span class="n">itr</span><span class="p">[</span><span class="n">MAX</span><span class="p">];</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="n">add_edge</span><span class="p">(</span><span class="kt">int</span> <span class="n">from</span><span class="p">,</span> <span class="kt">int</span> <span class="n">to</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cap</span><span class="p">){</span>
</span><span class="line">    <span class="n">G</span><span class="p">[</span><span class="n">from</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">edge</span><span class="p">{</span><span class="n">to</span><span class="p">,</span> <span class="n">cap</span><span class="p">,</span> <span class="kt">int</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">to</span><span class="p">].</span><span class="n">size</span><span class="p">())});</span>
</span><span class="line">    <span class="n">G</span><span class="p">[</span><span class="n">to</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">edge</span><span class="p">{</span><span class="n">from</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">from</span><span class="p">].</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">)});</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="n">build_level</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">t</span><span class="p">){</span>
</span><span class="line">    <span class="n">memset</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">level</span><span class="p">));</span>
</span><span class="line">    <span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">que</span><span class="p">;</span>
</span><span class="line">    <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span><span class="line">    <span class="n">level</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">que</span><span class="p">.</span><span class="n">empty</span><span class="p">()){</span>
</span><span class="line">        <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">que</span><span class="p">.</span><span class="n">front</span><span class="p">();</span> <span class="n">que</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span><span class="line">        <span class="k">if</span><span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">t</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span><span class="line">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">G</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span><span class="line">            <span class="n">edge</span> <span class="o">&amp;</span><span class="n">e</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
</span><span class="line">            <span class="k">if</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">cap</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="n">or</span> <span class="n">level</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">to</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
</span><span class="line">            <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">to</span><span class="p">);</span>
</span><span class="line">            <span class="n">level</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">to</span><span class="p">]</span> <span class="o">=</span> <span class="n">level</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="n">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">t</span><span class="p">,</span> <span class="kt">int</span> <span class="n">f</span><span class="p">){</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">t</span><span class="p">)</span> <span class="k">return</span> <span class="n">f</span><span class="p">;</span>
</span><span class="line">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">i</span> <span class="o">=</span> <span class="n">itr</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">G</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span><span class="line">        <span class="n">edge</span> <span class="o">&amp;</span><span class="n">e</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
</span><span class="line">        <span class="k">if</span><span class="p">(</span><span class="n">level</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">to</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">level</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="n">or</span> <span class="n">e</span><span class="p">.</span><span class="n">cap</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
</span><span class="line">        <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">to</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">min</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">cap</span><span class="p">));</span>
</span><span class="line">        <span class="k">if</span><span class="p">(</span><span class="n">d</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class="line">            <span class="n">e</span><span class="p">.</span><span class="n">cap</span> <span class="o">-=</span> <span class="n">d</span><span class="p">;</span>
</span><span class="line">            <span class="n">G</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">to</span><span class="p">][</span><span class="n">e</span><span class="p">.</span><span class="n">rev</span><span class="p">].</span><span class="n">cap</span> <span class="o">+=</span> <span class="n">d</span><span class="p">;</span>
</span><span class="line">            <span class="k">return</span> <span class="n">d</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="n">dinic</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">t</span><span class="p">){</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">flow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">f</span><span class="p">;</span>
</span><span class="line">    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
</span><span class="line">        <span class="n">build_level</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
</span><span class="line">        <span class="k">if</span><span class="p">(</span><span class="n">level</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="n">flow</span><span class="p">;</span>
</span><span class="line">        <span class="n">memset</span><span class="p">(</span><span class="n">itr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">itr</span><span class="p">));</span>
</span><span class="line">        <span class="k">while</span><span class="p">(</span><span class="n">f</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">inf</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">flow</span> <span class="o">+=</span> <span class="n">f</span><span class="p">;;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dijkstra法]]></title>
    <link href="http://algoogle.hadrori.jp/dijkstra/"/>
    <updated>2014-04-28T00:00:00+09:00</updated>
    <id>http://algoogle.hadrori.jp/dijkstra</id>
    <content type="html"><![CDATA[<h4 id="section">基本情報</h4>

<hr />

<table>
  <tbody>
    <tr>
      <td>計算量</td>
      <td>O(E log V)</td>
    </tr>
    <tr>
      <td>用途</td>
      <td>負辺のないグラフで単一始点最短路を求める.</td>
    </tr>
  </tbody>
</table>

<p>E := 辺の数<br />
V := 頂点の数  </p>

<h4 id="section-1">問題</h4>

<hr />

<ul>
  <li><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1156">AOJ 1157 “Twirling Robot”</a></li>
  <li><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1162">AOJ 1162 “Discrete Speed”</a></li>
  <li><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2151">AOJ 2151 “Brave Princess Revisited”</a></li>
  <li><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1150">AOJ 1150 “Cliff Climbingt”</a></li>
  <li><a href="http://poj.org/problem?id=2387">POJ 2387 “Til the Cows Come Home”</a></li>
  <li><a href="http://poj.org/problem?id=3268">POJ 3268 “Silver Cow Party”</a></li>
  <li><a href="http://poj.org/problem?id=2227">POJ 2227 “The Wedding Juicer”</a></li>
</ul>

<h4 id="section-2">解説</h4>

<hr />

<p>負辺の無いグラフで始点が決まっている時, その点からグラフ上の各頂点までの最短距離を求めることができる.<br />
Dijkstra法ではまだ調べていない頂点のうち, 始点から一番近い点を順に見ていき, その点からいける点の最短距離を更新していく.<br />
負辺がないのですでに調べている点はこれによって更新されることはなく, したがって順に最短路を求めることができる.  </p>

<p>まだ調べていない頂点のうち一番近い点というのは, 到達したかどうかのメモとpriority_queueなどのデータ構造を使うことで効率よく求めることができる.  </p>

<p>またpriority_queueは値が大きいものが基本的に優先されるので, greaterを指定して小さい方から取ってこさせるか, コードのように比較の不等号の意味を逆に定義させる.  </p>

<h4 id="section-3">コード</h4>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span> (dijkstra.cpp)</span> <a href="http://algoogle.hadrori.jp/downloads/code/dijkstra.cpp">download</a></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
</pre></td><td class="code"><pre><code class="cpp"><span class="line"><span class="k">struct</span> <span class="n">node</span><span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="n">d</span><span class="p">;</span>
</span><span class="line">    <span class="n">node</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">d</span><span class="p">)</span><span class="o">:</span><span class="n">v</span><span class="p">(</span><span class="n">v</span><span class="p">),</span><span class="n">d</span><span class="p">(</span><span class="n">d</span><span class="p">){}</span>
</span><span class="line">    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">node</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">)</span><span class="k">const</span><span class="p">{</span> <span class="k">return</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">.</span><span class="n">d</span><span class="p">;}</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line"><span class="k">struct</span> <span class="n">edge</span><span class="p">{</span><span class="kt">int</span> <span class="n">to</span><span class="p">,</span> <span class="n">d</span><span class="p">;};</span>
</span><span class="line"><span class="kt">int</span> <span class="n">V</span><span class="p">;</span>
</span><span class="line"><span class="n">vector</span><span class="o">&lt;</span><span class="n">edge</span><span class="o">&gt;</span> <span class="n">G</span><span class="p">[</span><span class="n">MAX</span><span class="p">];</span>
</span><span class="line"><span class="kt">int</span> <span class="n">dist</span><span class="p">[</span><span class="n">MAX</span><span class="p">];</span> <span class="c1">// ここに最短距離が入る</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="n">dijkstra</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">){</span>
</span><span class="line">    <span class="n">memset</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">dist</span><span class="p">));</span>
</span><span class="line">    <span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">node</span><span class="o">&gt;</span> <span class="n">que</span><span class="p">;</span>
</span><span class="line">    <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
</span><span class="line">    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">que</span><span class="p">.</span><span class="n">empty</span><span class="p">()){</span>
</span><span class="line">        <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">que</span><span class="p">.</span><span class="n">top</span><span class="p">().</span><span class="n">v</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">que</span><span class="p">.</span><span class="n">top</span><span class="p">().</span><span class="n">d</span><span class="p">;</span>
</span><span class="line">        <span class="n">que</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span><span class="line">        <span class="k">if</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="n">and</span> <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">d</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
</span><span class="line">        <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
</span><span class="line">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">G</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">            <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">to</span><span class="p">,</span> <span class="n">d</span><span class="o">+</span><span class="n">G</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">d</span><span class="p">));</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Aho-Corasick法]]></title>
    <link href="http://algoogle.hadrori.jp/aho-corasick/"/>
    <updated>2014-04-27T00:00:00+09:00</updated>
    <id>http://algoogle.hadrori.jp/aho-corasick</id>
    <content type="html"><![CDATA[<h4 id="section">基本情報</h4>

<hr />

<table>
  <tbody>
    <tr>
      <td>計算量</td>
      <td>O(N+M)</td>
    </tr>
    <tr>
      <td>用途</td>
      <td>入力文字列に対してマッチするパターンを検索</td>
    </tr>
  </tbody>
</table>

<p>N := 入力文字列の長さ<br />
M := パターンの文字列の長さの合計  </p>

<h4 id="section-1">問題</h4>

<hr />

<ul>
  <li><a href="http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2212">AOJ 2212 “Stolen Juwel”</a></li>
  <li><a href="http://poj.org/problem?id=1204">POJ 1204 “Word Puzzles”</a></li>
  <li><a href="http://poj.org/problem?id=3773">POJ 3373 “String-Matching Automata”</a></li>
  <li><a href="http://poj.org/problem?id=3691">POJ 3691 “DNA repair”</a></li>
</ul>

<h4 id="section-2">解説</h4>

<hr />

<p>まず各パターンからトライ木を作成する.  <br />
トライ木というのは例えば6つの文字列{a, ab, aca, ba, c, cab}に対して以下のような木のこと.<br />
<img src="http://algoogle.hadrori.jp/images/trie_tree.jpg" alt="trie_tree" /><br />
この木は文字列の頭に{a, ab, aca, ba, c, cab}に一致するものがあるか根から順に追うことで調べることができる.<br />
例えabcという文字列はroot-&gt;a-&gt;abまでいけるのでaとabが先頭にあることがわかる.<br />
Aho-Corasick法では, このトライ木を利用してで入力文字列の連続している部分文字列にパターンに一致するものがあるか, またそれは何かを文字列を先頭から順に見るだけで調べることを可能にする.  </p>

<p>トライ木の各ノードまでで構成される文字列について, その文字列の末尾と一致するノードのうち長さが最大のノードに辺を張る. もし存在しなければルートに張ることになる.<br />
これは幅優先探索によって容易に実装できる. 以下はそれらの辺を張った後のトライ木. またパターンと一致するノードを灰色に塗ってある.<br />
<img src="http://algoogle.hadrori.jp/images/suffix_link.jpg" alt="suffix_link" /><br />
しかしこのままだと短い文字列に一致していてもわからない場合があるので(例えばcabまで一致したとき, abに辺を張るがaには張らないので見落とす), 各ノードはその祖先が一致した文字列の情報も持つようにする.  </p>

<h4 id="section-3">コード</h4>

<hr />

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span> (aho_corasick.cpp)</span> <a href="http://algoogle.hadrori.jp/downloads/code/aho_corasick.cpp">download</a></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
</pre></td><td class="code"><pre><code class="cpp"><span class="line"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">struct</span> <span class="n">PMA</span><span class="p">{</span>
</span><span class="line">    <span class="n">PMA</span><span class="o">*</span> <span class="n">next</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
</span><span class="line">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">matched</span><span class="p">;</span>
</span><span class="line">    <span class="n">PMA</span><span class="p">(){</span><span class="n">memset</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">next</span><span class="p">));}</span>
</span><span class="line">    <span class="o">~</span><span class="n">PMA</span><span class="p">(){</span><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="k">if</span><span class="p">(</span><span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">delete</span> <span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">];}</span>
</span><span class="line"><span class="p">};</span>
</span><span class="line">
</span><span class="line"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">set_union</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">){</span>
</span><span class="line">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
</span><span class="line">    <span class="n">set_union</span><span class="p">(</span><span class="n">all</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">all</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">back_inserter</span><span class="p">(</span><span class="n">res</span><span class="p">));</span>
</span><span class="line">    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="n">PMA</span> <span class="o">*</span><span class="n">buildPMA</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">pattern</span><span class="p">){</span>
</span><span class="line">    <span class="n">PMA</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PMA</span><span class="p">,</span> <span class="o">*</span><span class="n">now</span><span class="p">;</span>
</span><span class="line">    <span class="n">root</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
</span><span class="line">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pattern</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span><span class="line">        <span class="n">now</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
</span><span class="line">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">pattern</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
</span><span class="line">            <span class="k">if</span><span class="p">(</span><span class="n">now</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[(</span><span class="kt">int</span><span class="p">)</span><span class="n">pattern</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span><span class="line">                <span class="n">now</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[(</span><span class="kt">int</span><span class="p">)</span><span class="n">pattern</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PMA</span><span class="p">;</span>
</span><span class="line">            <span class="n">now</span> <span class="o">=</span> <span class="n">now</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[(</span><span class="kt">int</span><span class="p">)</span><span class="n">pattern</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]];</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="n">now</span><span class="o">-&gt;</span><span class="n">matched</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="n">queue</span><span class="o">&lt;</span><span class="n">PMA</span><span class="o">*&gt;</span> <span class="n">que</span><span class="p">;</span>
</span><span class="line">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span><span class="line">        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
</span><span class="line">        <span class="k">else</span> <span class="p">{</span>
</span><span class="line">            <span class="n">root</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
</span><span class="line">            <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">que</span><span class="p">.</span><span class="n">empty</span><span class="p">()){</span>
</span><span class="line">        <span class="n">now</span> <span class="o">=</span> <span class="n">que</span><span class="p">.</span><span class="n">front</span><span class="p">();</span> <span class="n">que</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span><span class="line">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span><span class="line">            <span class="k">if</span><span class="p">(</span><span class="n">now</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">]){</span>
</span><span class="line">                <span class="n">PMA</span> <span class="o">*</span><span class="n">nxt</span> <span class="o">=</span> <span class="n">now</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span><span class="line">                <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">nxt</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="n">nxt</span> <span class="o">=</span> <span class="n">nxt</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span><span class="line">                <span class="n">now</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">nxt</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class="line">                <span class="n">now</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">matched</span> <span class="o">=</span> <span class="n">set_union</span><span class="p">(</span><span class="n">now</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">matched</span><span class="p">,</span> <span class="n">nxt</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">matched</span><span class="p">);</span>
</span><span class="line">                <span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">now</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span><span class="line">            <span class="p">}</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="kt">void</span> <span class="n">match</span><span class="p">(</span><span class="n">PMA</span><span class="o">*</span> <span class="o">&amp;</span><span class="n">pma</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">){</span>
</span><span class="line">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span><span class="line">        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class="line">        <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">pma</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>
</span><span class="line">            <span class="n">pma</span> <span class="o">=</span> <span class="n">pma</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span><span class="line">        <span class="n">pma</span> <span class="o">=</span> <span class="n">pma</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
</span><span class="line">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">pma</span><span class="o">-&gt;</span><span class="n">matched</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">            <span class="n">res</span><span class="p">[</span><span class="n">pma</span><span class="o">-&gt;</span><span class="n">matched</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

]]></content>
  </entry>
  
</feed>
