---
layout: post
title: "Codeforces 461C Appleman and a Sheet of Paper"
date: 2014-08-27 15:10:34 +0900
comments: true
category: Codeforces
tags: [segment-tree]
---

[Appleman and a Sheet of Paper](http://codeforces.com/contest/461/problem/C)

#### 問題概要

****

長さnの紙を折っていきたい. 以下のクエリを捌け

 
* 紙の左端からpのところで左から右に折る

* 紙の左端から[l,r]の部分の紙の重なっている長さの総和を求める


#### 解法

****

まず左から右に折るというのを, pが現在の長さの半分より大きいなら右から左におることにする.  
またその次からは右から左にpを見るようにして, 大きいpが来るたびにこの反転を繰り返す.  
これによって区間\[0,n)で処理できるようになる.  
以下の機能を持つSegment Treeを実装することでクエリを捌ける.  


* 区間の紙の重なっている量を持つ
* 区間の紙の厚さが一様かどうかを持つ
* 区間に一度に足された量を持つ
* 区間に値xを足す
* 区間[a,b)を区間[c,d)にひっくり返して足す
* 区間の重なっている長さの総和を求める


ひっくり返して足すときは, 区間が完全に含まれていてさらに厚さが一様ならその区間に対応する目的の区間にその厚さを足して, そうでないなら区間を分割していくのでよい.  
また更新するときに区間の一部だけ足されることがあったらその区間の厚さは一様ではなくなる.  
  
  
実は更新はナイーブに行ってもよい.  
長さnが減っていくことを考えると更新回数は高々n回になる.  
このことを利用すると, 各地点での和をBITで持つことによって更新全体でO(n log n), 総和の計算にはそれぞれO(log n)で答えることができる.  
また実装も平易なものになる.

#### コード

****

{% include_code Codeforces/461C.cpp %}
