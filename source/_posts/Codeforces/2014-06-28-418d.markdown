---
layout: post
title: "Codeforces 418D Big Problems for Organizers"
date: 2014-06-28 00:32:28 +0900
comments: true
category: Codeforces
tags: [tree, lowest-common-ancestor, doubling, data-structure]
---

[Big Problems for Organizers](http://codeforces.com/problemset/problem/418/D)

#### 問題概要

****

頂点数n(<=100000)の木が与えられる. この時m回以下のクエリが与えられる.  
頂点u, vから最も遠い点との距離はいくらか. ただし距離はu, vからのそれぞれの距離のうち小さい方を使う.

#### 解法

****

便宜上適当な頂点を根としておく.  
2頂点の中間部分で木を分解すれば, その木の根をそれぞれu, vとすることで木の高さが最長距離に当たる.  
  
クエリのu, vは深さの降順になっているとする.  
w = LCA(u,v)とすると, 分割点cはdepth[u] = depth[v]ならw, そうでないならuとwの間にある.  
  
そうするとuを含む方の木は以下の場合分けで高さが求まる.  

* 元の木でuの子孫に最も遠い点がある
* uとcの間にuから最も遠い点がある

部分木の高さは各点の深さと一緒に計算すればよい(O(n)).  
ここでuとcの間というのは, uの祖先だけでなく, 祖先の子孫も含む(ただしu以下は含まない).  
これはdoublingで2の冪個先の祖先までの区間について求めておけばO(log n)で求まる(構築はO(n log n)).  
これでuを含む方の木については調べられた.  
  
v(とw)を含む木の方は, 以下の場合分けで求まる  

* vの子孫に最も遠い点がある
* vとwの間にvまでの最も遠い点がある
* wと根の間にvまでの最も遠い点がある
* vとcの間にvまでの最も遠い点がある
* その他のwの子孫(子供が根になる部分木にv, cを含まない)に最も遠い点がある

始めの3つはuの時と同じdoublingで求めてあるやつを使えば良い.  
4つ目は今までのと似ているが, 基準の点が祖先の方なので別に用意する(似たようなdoublingをするだけ).  
最後は各頂点に対してその頂点を根とする部分木の高さを求めるとき, その子を根とする部分木の高さが最も大きい3つを保存すれば良い.  
そのとき子供の番号も保存しておけば, その頂点がvまたはcの祖先にいるかで使うかどうかを決めることができる.  
  
以上をバグらないように実装する.

#### コード

****

{% include_code Codeforces/418D.cpp %}
