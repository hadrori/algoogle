---
layout: post
title: "AOJ 2270 The L-th Number"
date: 2015-08-08 20:06:20 +0900
comments: true
category: AOJ
tags: [wavelet-matrix, lowest-common-ancestor]
---

[The L-th Number](http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2270)

#### 問題概要

****

頂点に値が割り当てられてる木について以下のクエリQ個を捌け．

* 2頂点v,w間のパス上の頂点のうち，l番目に小さいものを出力

#### 解法

****

全体の方針としては，wavelet行列で列にした木上の2区間(パスをLCAで2つに分割したもの)内のL番目の数字を求める．  
全体の計算量は最大値をMとして{% m %}O((Q+N)\log M){% em %}  
  
適当な頂点を根にしてオイラーツアーして木の頂点の値を列にする．またこのときLCAの準備もしておく．  
このとき入る時の値の列pと出る時の値の列qを作る．  
p,qはpに0でない値が入っている位置はqでは0で，qに0でない値が入っている位置はpでは0になるようにする．  
例えばオイラーツアーしてできる頂点番号の列が
```
1 2 2 3 4 4 3 1
```
だとして，それぞれ値が頂点番号と同じだとしたら
```
p : 1 2 0 3 4 0 0 0
q : 0 0 2 0 0 4 3 1
```
となる．  
このpとqについてのwavelet行列を生成する．  
このp，qでパス上の頂点の値の出現回数がわかるようになる．同じ区間で見て，pで増えて，qで減るから．  
  
{% m %}u := LCA(v,w){% em %}とする．  
オイラーツアーしてできた列は頂点b,とその祖先a間のパスを，{% m %}[in(a),in(b)]{% em %}と表現できる(途中のいらない部分木は頂点に入るのと出るので打ち消されてる)．  
ここで{% m %}in(a){% em %}とは列上で頂点aに入る位置．  
あとはこうしてできた2区間{% m %}[in(u),in(v)], [in(u)+1,in(w)]{% em %}上でL番目に小さい値を求めればよい．  
あとは1つの区間でK番目に大きいものを求めるものを応用させればよい(詳しくはコードを参照してほしい)．  
ざっくり言うと，最上位bitからみて区間内で有効な値のうち1が立ってる数がLより大きいかどうかでwavelet行列の行上の区間を選んでいく．

#### コード

****

{% include_code AOJ/2270.cpp %}
