---
layout: post
title: "PA 2010 Termites"
date: 2014-11-09T22:48:00+09:00
comments: true
category: PA
tags: [greedy]
---

[Termites](http://main.edu.pl/en/archive/pa/2010/ter)

#### 問題概要

****

長さnの数列aがある.  
今, 0に隣接した正の数を0にかえてその分の値をスコアとして得る.  
これを2人で交互に繰り返す.  
どちらも最適な行動を取るとき得られるスコアの総和を2人分求めよ.


#### 解法

****

問題の操作はstackとdequeがいくつかあって, そのいずれかでpopしていくかんじ.  
以降stackは配列の右側がtopで, 単調増加とかは左から右に見た時のことを指しているとする.  
こういうゲームは自分が相手よりいくら勝っているかを考えると考えやすいことが多い.  
前処理として数字をうまくマージすることでgreedyに落とすことができる.  
  
どういうときにgreedyでできるか考える.  
まずはdequeが1つの場合.  
列が単調であれば取る方は大きい方でよい.  
なぜなら偶数個であれば1個飛ばしで得られる列の大きいほうが得られ, 奇数個であればそれに一番小さい値が加わるだけだから.  
そのようなdequeが2つ以上の場合は？  
アクセス可能なところのうち大きい方から取ればよい.  
2つの場合を考えると最適な取り方は片方に単調性が崩れないようにもう片方を適当な位置に挿入したになるため.  
  
もう少しdequeを詰める.  
dequeだけど大きい方しか見てないことと2つ以上あっても動き方は変わらない.  
つまりdeque内の列が谷型でもよいということ(使わない小さい方を潰す).  
列を谷型に直すのは単調に直すのより簡単(山になってる部分をマージする).  
  
3つ並んだ数字x, y, zについて, `$x \leq y, z \leq y$`を満たすときを考える.  
この部分のxにアクセス可能なとき, これを取ると相手がyを取る.  
これだけでは損だけでつらいのでzを取る(xを取らざるを得なかった状況でも当然zを取ることになる).  
つまりxを取るとは相手よりx+y-zだけ多く得ると考えることができるので, x, y, zをx+y-zに置き換える.  
これは多重にやってもいい. なぜなら置き換えた後はただの1つの数字だから.  
また適用する順序は関係ない.  
なぜならv, w, x, y, zとあるとき(条件は今は無視する),  
v, w, xをマージするとv-w+x, y, zとなる. これをマージするとv-w+x-y+zとなる.  
x, y, zをマージするとv, w, x-y+zとなる. これをマージするとv-w+x-y+zとなる.  
w, x, yをマージするとv, w-x+y, zとなる. これをマージするとv-w+x-y+zとなる.  
  
deque部分はこれでgreedyにできる！  
  
stack部分は？  
山部分が潰せるのは同じ.  
それが単調非減少ならdequeの単調なものと同じ.  
谷の形は前半がdequeと同じ.  
つまりあとは単調減少になってる部分.  
  
最後の2個x, y(`$x \geq y$`)を考える.  
片方がyを取ったとき, 相手はxを取るのが最善.  
なぜなら何もせずにx-yの差をつけることができるから.  
つまりどちらもこの最後の2個は他に取れるのがなくなるまで取らない.  
よって最初の個数の偶奇でどっちがとるか分かる(2個なので毎回同じ人が損する).  
もっと言うと初期の個数だけで決まるということは最初に取り除いて良い.  
これを繰り返すと単調減少になってる部分は消せる.  
  
これであとはアクセス可能な部分の値でgreedyにできる.  
priority queueに突っ込んでやりましょう.


#### コード

****

{{< includeCode "/PA/2010/termites.cpp" "cpp" >}}
