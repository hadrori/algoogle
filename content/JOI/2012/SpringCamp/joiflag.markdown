---
layout: post
title: "JOI 春合宿 2012 JOI Flag"
date: 2014-10-06T23:45:00+09:00
comments: true
category: JOI
tags: [implementation]
---

[JOI Flag](http://joisc2012.contest.atcoder.jp/tasks/joisc2012_joi_flag)

#### 問題概要

****

以下の操作で塗られる旗を考える.  
1辺が2^Kの正方形を4つの等しい大きさの正方形に分解する.  
そのうち3つはJ, O, Iを割り当てて埋める.  
残りの1つは再帰的に同じ操作を繰り返す.  
1マスしか残らなかったらJOIのいずれかを割り当てる.  
  
今N箇所がJOIのいずれかで塗られている旗がある.  
上の操作をして旗をつくりたい.  
既に塗られているマスを別の文字に変えるのにはコスト1かかる.  
コストの最小はいくらか

#### 解法

****

再帰的に分解しながらやればよい.  
各エリアに何個J, O, Iがそれぞれあるかと, そのエリアをまた分割する場合の最小のコストを求めていけばその正方形に対する最小のコストが求められる.  
今回はある正方形に対して  
左下＜右下＜左上＜右上  
と再帰的に定義してソートしておくことで各個数をO(KlogN)程度で求めた.  
実行時間に余裕があったようで毎回O(N)でカウントしても良かったらしい(空間に対してNが小さいので枝刈りで大幅に削れる).  
なので以下は蛇足.  
  
上の順番付けは2点を含む正方形のうち, 分割すると異なる正方形にそれぞれが属するような正方形を考えた.  
これは2点のx座標のビット列で異なるビットの最上位の値が分割された正方形の1辺の長さになるのでMSBを求めれば良い.  
y座標についても同様にやって大きい方を採用する.  
そのビットより上のビットは共通しているので立てたまま, 下のビットは0にしてやれば境界が求まる.  
この境界を元に上の大小関係を満たすように番号付けすれば2点の比較ができる.  
この順にならんでいればあとはupper\_bound-lower\_boundで個数が求まる


#### コード

****

{{< includeCode "/JOI/2012/joiflag.cpp" "cpp" >}}
